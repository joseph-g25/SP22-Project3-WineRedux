
from sklearn.cluster import KMeans, MiniBatchKMeans
from sklearn.metrics import silhouette_score

from .data_handling_lib import RANDOM_STATE


def KMeans_cluster_load(X, n_clusters, n_init=10, max_iter=300, random_state=RANDOM_STATE):
    """
    Create and fit a KMeans cluster algorithm with array/matrix X and parameters as state above

    Args:
        X (ndarray/DataFrame): DataFrame of X points to run clustering on.
        n_clusters (int): Number of clusters to create. 
        n_init (int, optional): Number of centroid seeds to run the algorithm on. Defaults to 10.
        max_iter (int, optional): Number of iterations to converge on a clustering solution. Defaults to 300.
        random_state (int, optional): Set random state seed. Defaults to RANDOM_STATE.

    Returns:
        KMeans : KMeans clustering classifier
    """
    kmeans_clf = KMeans(n_clusters=n_clusters,
                        n_init=n_init,
                        max_iter=max_iter,
                        random_state=random_state)

    kmeans_clf.fit(X=X)
    return kmeans_clf

def mini_KMeans_cluster_load(X, n_clusters=8, n_init=10,
                             max_iter=300, random_state=RANDOM_STATE):
    """AI is creating summary for mini_KMeans_cluster_load

    Args:
        X ([type]): [description]
        n_clusters (int, optional): [description]. Defaults to 8.
        n_init (int, optional): [description]. Defaults to 10.
        max_iter (int, optional): Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics. Defaults to 300.
        random_state (int, optional): Set random state seed. Defaults to RANDOM_STATE.

    Returns:
        [type]: [description]
    """

    mini_kmeans_clf = MiniBatchKMeans(n_clusters=n_clusters, n_init=n_init,
                                      max_iter=max_iter, random_state=random_state)
    
    mini_kmeans_clf.fit(X=X)
    return mini_kmeans_clf

def make_kmeans_set(X, range_lower=1, range_upper=10, step=1):
    """Create a list 

    Args:
        X ([type]): [description]
        range_lower (int, optional): [description]. Defaults to 1.
        range_upper (int, optional): [description]. Defaults to 10.
        step (int, optional): [description]. Defaults to 1.

    Returns:
        [type]: [description]
    """
    kmeans_set = [KMeans(n_clusters=k, random_state=42).fit(X=X)
                for k in range(range_lower, range_upper, step)]
    return kmeans_set

def give_inertias_(kmeans_set):
    """
    Give the inertia_ scores for each member of kmeans_set. 

    Args:
        kmeans_set (list): A set of KMeans clusters with k varying n_clusters parameters. 

    Returns:
        [list]: List of inertia_ scores generated by each member of kmeans_set
    """
    inertias_ = [model.inertia_ for model in kmeans_set]
    return inertias_

def give_silhouette_scores(X, range_lower=1, range_upper=10, step=1, kmeans_set=None):
    """
    Give the Silhouette Scores for a set of KMeans clustering algorithms.
    
    If a set of KMeans classifiers is given, the function will use that to determine silhouette 
    scores. Else, a set of KMeans classifiers will be generated according to defined upper and
    lower bounds.
    
    Args:
        X (DataFrame): Original feature array which KMeans has been fitted on.
        range_lower (int, optional): [description]. Defaults to 1.
        range_upper (int, optional): [description]. Defaults to 10.
        step (int, optional): [description]. Defaults to 1.
        kmeans_set ([type], optional): [description]. Defaults to None.

    Returns:
        [type]: [description]
    """
    if kmeans_set is not None:
        silhouette_scores = [silhouette_score(X, model.labels_)
                     for model in kmeans_set[1:]]

        return silhouette_scores

    else:
        kmeans_set = make_kmeans_set(X=X, range_lower=range_lower,
                                    range_upper=range_upper, step=step)

        silhouette_scores = [silhouette_score(X, model.labels_)
                     for model in kmeans_set[1:]]

        return silhouette_scores
